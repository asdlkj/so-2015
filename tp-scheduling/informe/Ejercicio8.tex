\section{Ejercicio 8}


\subsection{Desarrollo}
Similar  a lo visto en el ejercicio 8, tendremos que programar la estrutura de un scheduler de Round-Robin. La diferencia es que en este caso en vez de tener una cola única que vaya guardando todos los procesos, cada core tendrá su propia cola de procesos. Para resolver esto utilizaremos una estructura para representar el core que nos dará la siguiente información: un entero pidActual, un entero quantum$\_$restante$\_$actual, su cola de pids enEspera, un booleano que indica cuando está bloqueado.

Después tenemos la cantidad de cores y el quantum de los mismos. Por último necesitamos agrupar las estructuras core que tenemos. Para esto usamos simplemente un vector (nucleos).

La función load lo que hace es buscar cual de los cores tiene menor cantidad de procesos. Una vez encontrado, se pregunta si se está ejecutando la tarea IDLE entonces pone el pid en pidActual. Si no, lo encola en el enEspera del core.

unblock lo que hace es buscar cual es el core donde se encuentra el pid que se desea bloquear, una vez encontrado se asigna true a la variable bloqueado.

Por último tenemos la función tick. El código es equivalente al del ejercicio 4.


\subsection{Experimentación}
Según lo pedido debemos mencionar un caso donde la migración de nucleos sea beneficiosa y otro donde no. Para lo segundo, usaremos dos core y cuatro tareas que iran apereciendo
en este orden: la más costosa,  la menos costosa, la segunda más costosa y la segunda menos costosa. Usaremos, en los dos cores, un quantum de 20 y nos queda lo siguiente:

\begin{figure}[H]
  \centering
    \includegraphics[width=1.1\textwidth]{imagenes/Ej8Experimento1.png}
  \caption{loteEj8Experimento1.tsk con RR2}
\end{figure}

Para el caso en el que sea beneficiosa vamos a usar el mismo lote de tareas, pero las cambiaremos de orden para que sean así: 
la más costosa, la segunda más costosa, la menos costosa y la segunda menos costosa. Nos queda lo siguiente:

\begin{figure}[H]
  \centering
    \includegraphics[width=1.1\textwidth]{imagenes/Ej8Experimento2.png}
  \caption{loteEj8Experimento2.tsk con RR2}
\end{figure}

Podemos ver que efectivamente el primer gráfico muestra que se tarda más en completar los procesos. Esto se debe a que el orden que le dimos a las tareas hace que el primer
procesador se le asigne las tareas más largas y costosas, mientras que el segundo tiene las más cortas. En ese sentido se muestra como la mayor parte del trabajo recae en uno de ellos
mientras que el otro termina y queda en ready mucho más rapido. Para el segundo experimento, al cambiar el orden podemos apreciar que los dos procesadores tienen una tarea
muy costosa y otra no tanto. Efectivamente termina más rápido ya que el trabajo se distribuye de forma más justa.