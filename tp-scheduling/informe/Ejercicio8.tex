\section{Ejercicio 8}


\subsection{Desarrollo}
Similar  a lo visto en el ejercicio 8, tendremos que programar la estrutura de un scheduler de Round-Robin. La diferencia es que en este caso en vez de tener una cola única que vaya guardando todos los procesos, cada core tendrá su propia cola de procesos. Para resolver esto utilizaremos una estructura para representar el core que nos dará la siguiente información: un entero pidActual, un entero quantum$\_$restante$\_$actual, su cola de pids enEspera, un booleano que indica cuando está bloqueado.

Después tenemos la cantidad de cores y el quantum de los mismos. Por último necesitamos agrupar las estructuras core que tenemos. Para esto usamos simplemente un vector (nucleos).

La función load lo que hace es buscar cual de los cores tiene menor cantidad de procesos. Una vez encontrado, se pregunta si se está ejecutando la tarea IDLE entonces pone el pid en pidActual. Si no, lo encola en el enEspera del core.

unblock lo que hace es buscar cual es el core donde se encuentra el pid que se desea bloquear, una vez encontrado se asigna true a la variable bloqueado.

Por último tenemos la función tick. El código es equivalente al del ejercicio 4.


\subsection{Experimentación}
Según lo pedido debemos mencionar un caso donde la 